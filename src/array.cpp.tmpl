#include "src/array.tdef"
// This file is generated.

#for $type in $types
#if $type.include
\#include "$(type.include)"
#end if
#end for

static array_alloc_t alloc;
static array_realloc_t realloc;
static array_free_t free;

void array_set_alloc(array_alloc_t a, array_realloc_t r, array_free_t f)
{
	alloc = a;
	realloc = r;
	free = f;
}


#for $type in $types
#set arname= "array_" + $type.name
$(type.full_name)& $(arname)::operator[](uint32_t idx)
{
	return buffer[idx];
}

void $(arname)_create(struct $(arname)* array)
{
	array->buffer = 0;
	array->size = 0;
	array->capacity = 0;
}

void $(arname)_destroy(struct $(arname)* array)
{
	free(array->buffer);
	*array = (struct $(arname)){};
}

void $(arname)_change_capacity(struct $(arname)* array, uint32_t new_capacity)
{
	realloc(array->buffer, new_capacity);
	array->capacity = new_capacity;
}


void $(arname)_resize(struct $(arname)* array, uint32_t new_size)
{
	if(new_size > array->capacity)
	{
		$(arname)_change_capacity(array, new_size);
	}

	array->size = new_size;
}

void $(arname)_push_back(struct $(arname)* array, #if $type.by_value then $type.full_name else $type.full_name + '*' # element)
{
	if(array->size > array->capacity - 1)
	{
		$(arname)_change_capacity(array, array->capacity * 2);
	}

	array->buffer[array->size++] = #if $type.by_value then "element" else "*element" #;
}

void $(arname)_remove(struct $(arname) array, uint32_t index)
{
	array->buffer[index] = array->buffer[array->size - 1];
	array->size--;
}

#end for